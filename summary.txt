1. Why did you choose the tools, libraries, and language you used for the coding exercise?

I chose to use Javascript and Node.js with the Express.js framework to build the API for the coding exercise. There are several reasons to justify why I used these tools, libraries, and language. 

Firstly, I chose Javascript as the language since it is one of the most widely used programming languages. Node.js allows Javascript to be used for server-side programming, which lets Javascript be used for full-stack development, meaning that there is a consistent development environment. Javascript's popularity also leads it to having an active community which can help speed up development as there are many resources to turn to.

I chose to use Node.js with Express.js since Node.js is lightweight and ideal for handling asynchronous operations simultaneously. Node.js is also non-blocking and event-driven, making it ideal for scaled APIs as it can handle a large number of requests. I used Express.js as it handles routing, middleware, and simplifies and speeds up many tasks involved with API development. I also used the NPM ecosystem due to the plethora of packages available. I used the js-priority-queue library for instance to implement a MinHeap with ease to track the transactions. 


2. What are the advantages and disadvantages of your solution?

Advantages:
- Efficiency/Scalability: By using a MinHeap to track the transactions, the solution is efficient in retrieving the oldest transactions as there is no need to sort every time the user spends. This improves the efficiency of the '/spend' endpoint from O(nlogn), which is the efficiency of sorting the transactions every time, to O(log n), which is the efficiency of adding and removing from a MinHeap. The efficient nature of this solution also allows it to be easily scalable.
- Clear and Maintainable: The code is clearly structured, properly named, and readable in terms of spacing and syntax. This is important as it makes it easy for other developers in a team setting.
- Edge Case Handling: The solution also addresses a lot of edge cases that were not clearly specified. For instances, it handles the case of the '/add' endpoint leading to payer total's in the negative, which is not allowed and accounts for zero-point transactions. The solution is robust.

Disadvantages:
- In-Memory Storage: The solution can easily be improved by storing the data externally, rather than within the implementation itself, which is a bottleneck. This can be dangerous as in the case that the server crashes or restarts, all the data will be erased. It also prevents the API from being scalable as memory is finite and cannot be overused in the API to ensure efficiency. This also might prevents data from persisting across multiple sessions which makes it not as useful in real-time applications.
- Security: The application can also be improved int terms of input sanitation, authentication, and authorization. This prevents malicious inputs and maintain proper access.

3. What has been a favorite school/personal project thus far? What about it that challenged you?

A favorite personal project of mine has been developing the iOS app, Weave. I really loved this project since it solved a problem that I and many of my peers were facing-overscreenshotting. I came to realize that people often take screenshots to save information, but these screenshots are static and lack interactivity and functionality. Another observation I had was that people like to share and be social with screenshots, links, and lists, but everything in the market right now is unorganized. Accordingly, I built Weave to autodetect screenshots and use AI models to find relevant links to screenshots and make them actionable, allowing users to seamlessly use them in an effective manner. For example, a screenshot listing the Top 10 Restaurants would be presented with links to each restaurant's reservations/maps/websites in our app. Moreover, users can search for screenshot with natural language and create and share collections of screenshots with peers, as I implemented an Instagram-esque following, follower system. With over 1000 users, this app has given me the gratification of building products that people actually love and use. 

There were many challenges involved with the production of the app. On the technical side of things, making the application low latency and improving the accuracy of the AI model was very challenging. I was able to work around this however with effective Redux state management, lazy loading of images, batch API requests to prevent rate limits, and background processing cumbersome tasks. Implementing and bringing down the latency to a permissible level was extremely challenging as through customer research I became aware of how important the user experience is in order to sustain users. I was able to handle the AI challenges by doing extensive literature review on LLMs and CV and eventually implementing fine-tuning techniques and ReAct/Chain of Thought prompting and several techniques to optimize the AI. On the non-technical side of things, leading a team of 5 was a huge challenge of its own. Being able to lead a team, delegate tasks appropriately, and resolve issues as they come was extremely challenging. I had to learn to become a glue-man, whether that be by doing work that no one wanted to, such as wire-framing or resolving merge conflicts or teaching others about good coding practices so we can maintain a clean coding environment. This was especially important as at the start, the lack of consistent coding practices, whether that be adhering to SOLID principles, or lack of component structuring led to a very difficult time debugging. There were also instances where teammates were unsatisfied with the work they were doing or where team members slacked. Having these difficult conversations and keeping everyone on the same page was extremely difficult and a great learning lesson for me. Overall, this project was a very technically and non-technically challenging experience which has taught me a lot about working and leading in team settings and developing scalable software. 